/*
  ____                                   _             _
 / ___|  ___  _   _ _ __ ___ ___   _ __ | |_   _  __ _(_)_ __
 \___ \ / _ \| | | | '__/ __/ _ \ | '_ \| | | | |/ _` | | '_ \
  ___) | (_) | |_| | | | (_|  __/ | |_) | | |_| | (_| | | | | |
 |____/ \___/ \__,_|_|  \___\___| | .__/|_|\__,_|\__, |_|_| |_|
                                  |_|            |___/
# A Template for ArucoPlugin, a Source Plugin
# Generated by the command: plugin --type source --dir
/home/mirolab/src/aruco_plugin --install-dir /usr/local aruco # Hostname:
raspberrypi # Current working directory: /home/mirolab/src # Creation date:
2025-09-23T09:02:16.774+0100 # NOTICE: MADS Version 1.3.5
*/
// Mandatory included headers
#include <chrono>
#include <iostream>
#include <librealsense2/rs.hpp>
#include <nlohmann/json.hpp>
#include <opencv2/aruco.hpp>
#include <opencv2/opencv.hpp>
#include <pugg/Kernel.h>
#include <source.hpp>
#include <thread>

// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "aruco"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class ArucoPlugin : public Source<json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // ***************************************************************************
  void setup_realsense() {
    _cfg.enable_stream(RS2_STREAM_COLOR, 640, 480, RS2_FORMAT_BGR8, 30);
    _cfg.enable_stream(RS2_STREAM_DEPTH, 640, 480, RS2_FORMAT_Z16, 30);
    _pipe.start(_cfg);
  }

  // ***************************************************************************
  void setup_aruco() {
    _dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_4X4_50);
  }

  // ***************************************************************************
  void acquire_frames() {
    _frames = std::make_unique<rs2::frameset>(_pipe.wait_for_frames());
    _color_frame =
        std::make_unique<rs2::video_frame>(_frames->get_color_frame());
    _depth_frame =
        std::make_unique<rs2::depth_frame>(_frames->get_depth_frame());

    _color_img = cv::Mat(cv::Size(640, 480), CV_8UC3,
                         (void *)_color_frame->get_data(), cv::Mat::AUTO_STEP);
  }

  // ***************************************************************************
  void detect_markers() {
    _ids.clear();
    _corners.clear();
    cv::aruco::detectMarkers(_color_img, _dictionary, _corners, _ids);
    cv::aruco::drawDetectedMarkers(_color_img, _corners, _ids);
  }

  // ***************************************************************************
  void estimate_pose(json &out) {
    if (_ids.empty())
      return;
    rs2::video_stream_profile color_profile =
        _color_frame->get_profile().as<rs2::video_stream_profile>();
    rs2_intrinsics intrinsics = color_profile.get_intrinsics();
    for (size_t i = 0; i < _ids.size(); ++i) {
      cv::Point2f center(0, 0);
      for (int j = 0; j < 4; ++j)
        center += _corners[i][j];
      center *= 0.25f; // Calculate center of quadrilateral
      float pixel[2] = {center.x, center.y};
      float depth = _depth_frame->get_distance((int)center.x, (int)center.y);
      float point[3];
      rs2_deproject_pixel_to_point(point, &intrinsics, pixel, depth);
      std::cout << "ID: " << _ids[i]
                << " 3D Coordinates (meters): X=" << point[0]
                << " Y=" << point[1] << " Z=" << point[2] << std::endl;
      out["tag." + to_string(_ids[i])]["position"] = {point[0], point[1], point[2]};
    }
  }

  // ***************************************************************************
  void display() {
    if (!_color_img.empty()) {
      cv::imshow("RGB", _color_img);
      cv::waitKey(1);
    } else {
      std::cerr << "color_img is empty!" << std::endl;
    }
  }

  // Implement the actual functionality here
  return_type get_output(json &out,
                         std::vector<unsigned char> *blob = nullptr) override {
    out.clear();

    acquire_frames();
    detect_markers();
    estimate_pose(out);
    if (_params["display"].get<bool>()) {
      display();
    }
    return return_type::success;
  }

  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters
    // (e.g. agent_id, etc.)
    Source::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.
    _params["some_field"] = "default_value";
    _params["display"] = false;

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(*(json *)params);

    setup_realsense();
    setup_aruco();
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override {
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent

    return {{"display", (_params["display"].get<bool>() ? "ON" : "OFF")}};
  };

private:
  rs2::pipeline _pipe;
  rs2::config _cfg;
  cv::Mat _color_img;
  cv::Ptr<cv::aruco::Dictionary> _dictionary;
  std::vector<int> _ids;
  std::vector<std::vector<cv::Point2f>> _corners;
  std::unique_ptr<rs2::frameset> _frames;
  std::unique_ptr<rs2::video_frame> _color_frame;
  std::unique_ptr<rs2::depth_frame> _depth_frame;
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SOURCE_DRIVER(ArucoPlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  ArucoPlugin plugin;
  json output, params;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Process data

  while (1) {
    plugin.get_output(output);
    // std::this_thread::sleep_for(std::chrono::milliseconds(400));
    // std::cout << "aaaaaa" << std::endl;
  }

  // Produce output
  cout << "Output: " << output << endl;

  return 0;
}
